create table "public"."Categories" (
    "id" smallint generated by default as identity not null,
    "sequence" smallint,
    "name" character varying
);


create table "public"."ExpenseStatus" (
    "id" bigint generated by default as identity not null,
    "userId" uuid,
    "paid" boolean,
    "amount" numeric,
    "ratio" numeric,
    "updatedAt" timestamp with time zone default now(),
    "updatedBy" uuid
);


create table "public"."Expenses" (
    "id" bigint generated by default as identity not null,
    "groupId" uuid,
    "payer" uuid,
    "categoryId" smallint,
    "description" text,
    "methodId" smallint,
    "payment" numeric,
    "settled" boolean,
    "registeredAt" timestamp with time zone default now(),
    "registeredBy" uuid,
    "updatedAt" timestamp with time zone default now(),
    "updatedBy" uuid
);


create table "public"."Friendships" (
    "id" uuid not null default gen_random_uuid(),
    "userId" uuid,
    "friendId" uuid,
    "friendEmail" character varying,
    "registeredAt" timestamp with time zone default (now() AT TIME ZONE 'utc'::text),
    "updatedAt" timestamp with time zone default (now() AT TIME ZONE 'utc'::text),
    "statusId" smallint
);


create table "public"."GroupMembers" (
    "groupId" uuid not null,
    "friendshipId" uuid
);


create table "public"."Groups" (
    "id" uuid not null,
    "name" character varying,
    "registeredAt" timestamp with time zone default now(),
    "registeredBy" uuid,
    "updatedAt" timestamp with time zone default now(),
    "updatedBy" uuid
);


create table "public"."Methods" (
    "id" smallint generated by default as identity not null,
    "sequence" smallint,
    "name" character varying
);


create table "public"."Status" (
    "id" smallint generated by default as identity not null,
    "statusName" character varying
);


create table "public"."Users" (
    "firstName" character varying,
    "lastName" character varying,
    "email" character varying,
    "password" text,
    "registeredAt" timestamp with time zone,
    "updatedAt" timestamp with time zone,
    "id" uuid not null
);


CREATE UNIQUE INDEX categories_name_key ON public."Categories" USING btree (name);

CREATE UNIQUE INDEX categories_pkey ON public."Categories" USING btree (id);

CREATE UNIQUE INDEX categories_sequence_key ON public."Categories" USING btree (sequence);

CREATE UNIQUE INDEX expenses_pkey ON public."Expenses" USING btree (id);

CREATE UNIQUE INDEX expensestatus_pkey ON public."ExpenseStatus" USING btree (id);

CREATE UNIQUE INDEX friendships_pkey ON public."Friendships" USING btree (id);

CREATE UNIQUE INDEX groupmembers_pkey ON public."GroupMembers" USING btree ("groupId");

CREATE UNIQUE INDEX groups_pkey ON public."Groups" USING btree (id);

CREATE UNIQUE INDEX methods_pkey ON public."Methods" USING btree (id);

CREATE UNIQUE INDEX status_pkey ON public."Status" USING btree (id);

CREATE UNIQUE INDEX status_statusname_key ON public."Status" USING btree ("statusName");

CREATE UNIQUE INDEX users_pkey ON public."Users" USING btree (id);

alter table "public"."Categories" add constraint "categories_pkey" PRIMARY KEY using index "categories_pkey";

alter table "public"."ExpenseStatus" add constraint "expensestatus_pkey" PRIMARY KEY using index "expensestatus_pkey";

alter table "public"."Expenses" add constraint "expenses_pkey" PRIMARY KEY using index "expenses_pkey";

alter table "public"."Friendships" add constraint "friendships_pkey" PRIMARY KEY using index "friendships_pkey";

alter table "public"."GroupMembers" add constraint "groupmembers_pkey" PRIMARY KEY using index "groupmembers_pkey";

alter table "public"."Groups" add constraint "groups_pkey" PRIMARY KEY using index "groups_pkey";

alter table "public"."Methods" add constraint "methods_pkey" PRIMARY KEY using index "methods_pkey";

alter table "public"."Status" add constraint "status_pkey" PRIMARY KEY using index "status_pkey";

alter table "public"."Users" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."Categories" add constraint "categories_name_key" UNIQUE using index "categories_name_key";

alter table "public"."Categories" add constraint "categories_sequence_key" UNIQUE using index "categories_sequence_key";

alter table "public"."ExpenseStatus" add constraint "expensestatus_updatedby_fkey" FOREIGN KEY ("updatedBy") REFERENCES "Users"(id) ON DELETE SET NULL not valid;

alter table "public"."ExpenseStatus" validate constraint "expensestatus_updatedby_fkey";

alter table "public"."ExpenseStatus" add constraint "expensestatus_userid_fkey" FOREIGN KEY ("userId") REFERENCES "Users"(id) ON DELETE CASCADE not valid;

alter table "public"."ExpenseStatus" validate constraint "expensestatus_userid_fkey";

alter table "public"."Expenses" add constraint "expenses_categoryid_fkey" FOREIGN KEY ("categoryId") REFERENCES "Categories"(id) ON DELETE SET NULL not valid;

alter table "public"."Expenses" validate constraint "expenses_categoryid_fkey";

alter table "public"."Expenses" add constraint "expenses_groupid_fkey" FOREIGN KEY ("groupId") REFERENCES "Groups"(id) ON DELETE SET NULL not valid;

alter table "public"."Expenses" validate constraint "expenses_groupid_fkey";

alter table "public"."Expenses" add constraint "expenses_payer_fkey" FOREIGN KEY (payer) REFERENCES "Users"(id) not valid;

alter table "public"."Expenses" validate constraint "expenses_payer_fkey";

alter table "public"."Expenses" add constraint "expenses_registeredby_fkey" FOREIGN KEY ("registeredBy") REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."Expenses" validate constraint "expenses_registeredby_fkey";

alter table "public"."Expenses" add constraint "expenses_updatedby_fkey" FOREIGN KEY ("updatedBy") REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."Expenses" validate constraint "expenses_updatedby_fkey";

alter table "public"."Friendships" add constraint "friendships_friendid_fkey" FOREIGN KEY ("friendId") REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."Friendships" validate constraint "friendships_friendid_fkey";

alter table "public"."Friendships" add constraint "friendships_statusid_fkey" FOREIGN KEY ("statusId") REFERENCES "Status"(id) ON DELETE RESTRICT not valid;

alter table "public"."Friendships" validate constraint "friendships_statusid_fkey";

alter table "public"."Friendships" add constraint "friendships_userid_fkey" FOREIGN KEY ("userId") REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."Friendships" validate constraint "friendships_userid_fkey";

alter table "public"."GroupMembers" add constraint "groupmembers_friendshipid_fkey" FOREIGN KEY ("friendshipId") REFERENCES "Friendships"(id) not valid;

alter table "public"."GroupMembers" validate constraint "groupmembers_friendshipid_fkey";

alter table "public"."GroupMembers" add constraint "groupmembers_groupid_fkey" FOREIGN KEY ("groupId") REFERENCES "Groups"(id) ON DELETE CASCADE not valid;

alter table "public"."GroupMembers" validate constraint "groupmembers_groupid_fkey";

alter table "public"."Groups" add constraint "groups_registeredby_fkey" FOREIGN KEY ("registeredBy") REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."Groups" validate constraint "groups_registeredby_fkey";

alter table "public"."Groups" add constraint "groups_updatedby_fkey" FOREIGN KEY ("updatedBy") REFERENCES auth.users(id) ON DELETE SET NULL not valid;

alter table "public"."Groups" validate constraint "groups_updatedby_fkey";

alter table "public"."Status" add constraint "status_statusname_key" UNIQUE using index "status_statusname_key";

alter table "public"."Users" add constraint "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) not valid;

alter table "public"."Users" validate constraint "users_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.check_friendship(user_id uuid, friend_email character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN (
SELECT
    COUNT(*)
FROM
    "Friendships" f
LEFT OUTER JOIN
    "Users" uu ON f."friendId" = uu.id
LEFT OUTER JOIN
    "Users" uf ON f."userId" = uf.id
WHERE
    (uu.id = user_id OR uf.id = user_id) AND
    (uu.email = friend_email OR uf.email = friend_email OR f."friendEmail" = friend_email));
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_friends(user_id uuid)
 RETURNS TABLE(id uuid, "firstName" character varying, "lastName" character varying, email character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
SELECT
CASE WHEN uu.id = user_id THEN uf.id ELSE uu.id END AS "id",
    CASE WHEN uu.id = user_id THEN uf."firstName" ELSE uu."firstName" END AS "firstName",
    CASE WHEN uu.id = user_id THEN uf."lastName" ELSE uu."lastName" END AS "lastName",
    CASE WHEN uu.id = user_id AND uf.email IS NOT NULL THEN uf.email
         WHEN uu.id <> user_id AND uu.email IS NOT NULL THEN uu.email
         ELSE f."friendEmail" END AS email
FROM
    "Friendships" f
LEFT OUTER JOIN
    "Users" uu ON f."friendId" = uu.id
LEFT OUTER JOIN
    "Users" uf ON f."userId" = uf.id
WHERE
    uu.id = user_id OR uf.id = user_id
ORDER BY
    f."registeredAt" DESC;

END;
$function$
;
