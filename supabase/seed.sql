-- create table
--   public."Categories" (
--     id smallint generated by default as identity not null,
--     sequence smallint null,
--     name character varying null,
--     constraint Categories_pkey primary key (id),
--     constraint Categories_name_key unique (name),
--     constraint Categories_sequence_key unique (sequence)
--   ) tablespace pg_default;

-- INSERT INTO "Categories" (sequence, name)
-- VALUES (1, 'None'), (2, 'Food'), (3, 'Entertainment'), (4, 'Transportation'), (5, 'Cost of Living'), (6, 'Utility'), (7, 'Health'), (8, 'Beauty'), (9, 'Cloth'), (10, 'Others');

--   create table
--   public."Users" (
--     "firstName" character varying null,
--     "lastName" character varying null,
--     "email" character varying null,
--     "password" text null,
--     "registeredAt" timestamp with time zone null,
--     "updatedAt" timestamp with time zone null,
--     "id" uuid not null,
--     constraint Users_pkey primary key (id),
--     constraint Users_id_fkey foreign key (id) references auth.users (id)
--   ) tablespace pg_default;

--   create table
--   public."ExpenseStatus" (
--     "id" bigint generated by default as identity not null,
--     "userId" uuid null,
--     "paid" boolean null,
--     "amount" numeric null,
--     "ratio" numeric null,
--     "updatedAt" timestamp with time zone null default now(),
--     "updatedBy" uuid null,
--     constraint ExpenseStatus_pkey primary key (id),
--     constraint ExpenseStatus_updatedBy_fkey foreign key ("updatedBy") references "Users" (id) on delete set null,
--     constraint ExpenseStatus_userId_fkey foreign key ("userId") references "Users" (id) on delete cascade
--   ) tablespace pg_default;
  
--   create table
--   public."Friendships" (
--     "id" uuid not null default gen_random_uuid (),
--     "userId" uuid null,
--     "friendId" uuid null,
--     "friendEmail" character varying null,
--     "registeredAt" timestamp with time zone null default (now() at time zone 'utc'::text),
--     "updatedAt" timestamp with time zone null default (now() at time zone 'utc'::text),
--     "statusId" smallint null,
--     constraint Friendships_pkey primary key (id),
--     constraint Friendships_friendId_fkey foreign key ("friendId") references auth.users (id) on delete cascade,
--     constraint Friendships_statusId_fkey foreign key ("statusId") references "Status" (id) on delete restrict,
--     constraint Friendships_userId_fkey foreign key ("userId") references auth.users (id) on delete cascade
--   ) tablespace pg_default;

--   create table
--   public."Groups" (
--     "id" uuid not null,
--     "name" character varying null,
--     "registeredAt" timestamp with time zone null default now(),
--     "registeredBy" uuid null,
--     "updatedAt" timestamp with time zone null default now(),
--     "updatedBy" uuid null,
--     constraint Groups_pkey primary key (id),
--     constraint Groups_registeredBy_fkey foreign key ("registeredBy") references auth.users (id) on delete set null,
--     constraint Groups_updatedBy_fkey foreign key ("updatedBy") references auth.users (id) on delete set null
--   ) tablespace pg_default;

--   create table
--   public."GroupMembers" (
--     "groupId" uuid not null,
--     "friendshipId" uuid null,
--     constraint GroupMembers_pkey primary key ("groupId"),
--     constraint GroupMembers_friendshipId_fkey foreign key ("friendshipId") references "Friendships" (id),
--     constraint GroupMembers_groupId_fkey foreign key ("groupId") references "Groups" (id) on delete cascade
--   ) tablespace pg_default;

-- create table
--   public."Methods" (
--     "id" smallint generated by default as identity not null,
--     "sequence" smallint null,
--     "name" character varying null,
--     constraint Methods_pkey primary key (id)
--   ) tablespace pg_default;

--   create table
--   public."Expenses" (
--     "id" bigint generated by default as identity not null,
--     "groupId" uuid null,
--     "payer" uuid null,
--     "categoryId" smallint null,
--     "description" text null,
--     "methodId" smallint null,
--     "payment" numeric null,
--     "settled" boolean null,
--     "registeredAt" timestamp with time zone null default now(),
--     "registeredBy" uuid null,
--     "updatedAt" timestamp with time zone null default now(),
--     "updatedBy" uuid null,
--     constraint Expenses_pkey primary key (id),
--     constraint Expenses_categoryId_fkey foreign key ("categoryId") references "Categories" (id) on delete set null,
--     constraint Expenses_groupId_fkey foreign key ("groupId") references "Groups" (id) on delete set null,
--     constraint Expenses_payer_fkey foreign key (payer) references "Users" (id),
--     constraint Expenses_registeredBy_fkey foreign key ("registeredBy") references auth.users (id) on delete set null,
--     constraint Expenses_updatedBy_fkey foreign key ("updatedBy") references auth.users (id) on delete set null
--   ) tablespace pg_default;

-- create table
--   public."Status" (
--     "id" smallint generated by default as identity not null,
--     "statusName" character varying null,
--     constraint Status_pkey primary key (id),
--     constraint Status_statusName_key unique ("statusName")
--   ) tablespace pg_default;

-- CREATE OR REPLACE FUNCTION get_user_friends(user_id uuid)
-- RETURNS TABLE (
--     "id" uuid,
--     "firstName" varchar,
--     "lastName" varchar,
--     "email" varchar
-- ) AS $$
-- BEGIN
--     RETURN QUERY
-- SELECT
-- CASE WHEN uu.id = user_id THEN uf.id ELSE uu.id END AS "id",
--     CASE WHEN uu.id = user_id THEN uf."firstName" ELSE uu."firstName" END AS "firstName",
--     CASE WHEN uu.id = user_id THEN uf."lastName" ELSE uu."lastName" END AS "lastName",
--     CASE WHEN uu.id = user_id AND uf.email IS NOT NULL THEN uf.email
--          WHEN uu.id <> user_id AND uu.email IS NOT NULL THEN uu.email
--          ELSE f."friendEmail" END AS email
-- FROM
--     "Friendships" f
-- LEFT OUTER JOIN
--     "Users" uu ON f."friendId" = uu.id
-- LEFT OUTER JOIN
--     "Users" uf ON f."userId" = uf.id
-- WHERE
--     uu.id = user_id OR uf.id = user_id
-- ORDER BY
--     f."registeredAt" DESC;

-- END;
-- $$ LANGUAGE plpgsql;

-- CREATE OR REPLACE FUNCTION check_friendship(user_id uuid, friend_email varchar)
-- RETURNS integer AS $$
-- BEGIN
--     RETURN (
-- SELECT
--     COUNT(*)
-- FROM
--     "Friendships" f
-- LEFT OUTER JOIN
--     "Users" uu ON f."friendId" = uu.id
-- LEFT OUTER JOIN
--     "Users" uf ON f."userId" = uf.id
-- WHERE
--     (uu.id = user_id OR uf.id = user_id) AND
--     (uu.email = friend_email OR uf.email = friend_email OR f."friendEmail" = friend_email));
-- END;
-- $$ LANGUAGE plpgsql;
